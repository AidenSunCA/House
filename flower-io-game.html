<!DOCTYPE html>
<html>
<head>
    <title>Flower.io Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #87CEEB;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #gameCanvas {
            border: 5px solid #5a4a2a;
            background: #90EE90;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #FFD700;
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 15px;
            border: 3px solid #FFD700;
            text-align: center;
            color: white;
            z-index: 100;
        }
        #startScreen h1 {
            color: #FFD700;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #FFD700;
        }
        #startScreen button {
            background: #FFD700;
            color: black;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #startScreen button:hover {
            background: #FFA500;
        }
        #gameOverScreen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 15px;
            border: 3px solid #ff0000;
            text-align: center;
            color: white;
            z-index: 100;
        }
        #gameOverScreen h2 {
            color: #ff0000;
            font-size: 40px;
            margin-bottom: 20px;
        }
        #gameOverScreen button {
            background: #FFD700;
            color: black;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div>üå∏ Level: <span id="level">1</span></div>
        <div>‚≠ê XP: <span id="xp">0</span> / <span id="xpNeeded">10</span></div>
        <div>‚ù§Ô∏è Health: <span id="health">100</span></div>
        <div>üå∫ Petals: <span id="petals">0</span></div>
    </div>

    <div id="startScreen">
        <h1>üå∫ FLOWER.IO üå∫</h1>
        <p style="font-size: 18px; margin: 20px 0;">Collect petals to grow your flower!</p>
        <p>Defeat enemies and level up!</p>
        <p style="margin-top: 20px; font-size: 14px;"><strong>WASD</strong> - Move | <strong>Mouse</strong> - Auto attack nearest enemy</p>
        <button onclick="startGame()">START BLOOMING</button>
    </div>

    <div id="gameOverScreen">
        <h2>üíÄ WILTED üíÄ</h2>
        <p style="font-size: 24px; margin: 20px 0;">Level Reached: <span id="finalLevel">0</span></p>
        <p style="font-size: 20px;">Petals Collected: <span id="finalPetals">0</span></p>
        <button onclick="restartGame()">BLOOM AGAIN</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth - 100;
        canvas.height = window.innerHeight - 100;

        // Game variables
        let gameActive = false;
        let cameraX = 0;
        let cameraY = 0;

        // World size
        const WORLD_WIDTH = 2500;
        const WORLD_HEIGHT = 2500;

        // Player flower
        let player = {
            x: WORLD_WIDTH / 2,
            y: WORLD_HEIGHT / 2,
            size: 20,
            speed: 3,
            health: 100,
            maxHealth: 100,
            level: 1,
            xp: 0,
            xpNeeded: 10,
            petals: [],
            petalCount: 0,
            angle: 0
        };

        // Movement keys
        let keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };

        // Petals to collect
        let collectiblePetals = [];
        const PETAL_COUNT = 150;

        // Enemies
        let enemies = [];
        const ENEMY_TYPES = [
            { name: 'Ladybug', color: '#ff0000', size: 12, health: 20, damage: 5, speed: 1.5, xp: 5 },
            { name: 'Beetle', color: '#4169E1', size: 15, health: 30, damage: 10, speed: 1.2, xp: 10 },
            { name: 'Spider', color: '#000000', size: 18, health: 50, damage: 15, speed: 1, xp: 20 }
        ];

        // Projectiles
        let projectiles = [];

        const PETAL_COLORS = ['#FF69B4', '#FFD700', '#87CEEB', '#FF6347', '#9370DB', '#00FA9A'];

        function initPlayer() {
            player.x = WORLD_WIDTH / 2;
            player.y = WORLD_HEIGHT / 2;
            player.health = 100;
            player.maxHealth = 100;
            player.level = 1;
            player.xp = 0;
            player.xpNeeded = 10;
            player.petals = [];
            player.petalCount = 0;
            player.angle = 0;
        }

        function initPetals() {
            collectiblePetals = [];
            for (let i = 0; i < PETAL_COUNT; i++) {
                collectiblePetals.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    size: 8,
                    color: PETAL_COLORS[Math.floor(Math.random() * PETAL_COLORS.length)],
                    rotation: Math.random() * Math.PI * 2
                });
            }
        }

        function spawnEnemy() {
            const edge = Math.floor(Math.random() * 4);
            let x, y;

            switch(edge) {
                case 0: x = Math.random() * WORLD_WIDTH; y = 0; break;
                case 1: x = WORLD_WIDTH; y = Math.random() * WORLD_HEIGHT; break;
                case 2: x = Math.random() * WORLD_WIDTH; y = WORLD_HEIGHT; break;
                case 3: x = 0; y = Math.random() * WORLD_HEIGHT; break;
            }

            const levelFactor = Math.min(player.level / 5, 1);
            const typeIndex = Math.random() < levelFactor ? Math.floor(Math.random() * 3) : 0;
            const type = ENEMY_TYPES[typeIndex];

            enemies.push({
                x: x,
                y: y,
                size: type.size,
                color: type.color,
                health: type.health,
                maxHealth: type.health,
                damage: type.damage,
                speed: type.speed,
                xp: type.xp,
                name: type.name
            });
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameActive = true;
            initPlayer();
            initPetals();
            enemies = [];
            projectiles = [];
            gameLoop();
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            startGame();
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('finalLevel').textContent = player.level;
            document.getElementById('finalPetals').textContent = player.petalCount;
            document.getElementById('gameOverScreen').style.display = 'block';
        }

        function addPetal() {
            const angle = (player.petals.length / 8) * Math.PI * 2;
            player.petals.push({
                angle: angle,
                distance: 35,
                color: PETAL_COLORS[Math.floor(Math.random() * PETAL_COLORS.length)],
                size: 12,
                damage: 10 + player.level * 2
            });
        }

        function levelUp() {
            player.level++;
            player.health = player.maxHealth;
            player.xp = 0;
            player.xpNeeded = Math.floor(player.xpNeeded * 1.5);
            player.maxHealth += 20;
            player.health = player.maxHealth;

            // Add 2 petals per level
            addPetal();
            addPetal();
        }

        function updatePlayer() {
            // Movement
            let dx = 0;
            let dy = 0;

            if (keys.w) dy = -1;
            if (keys.s) dy = 1;
            if (keys.a) dx = -1;
            if (keys.d) dx = 1;

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            player.x += dx * player.speed;
            player.y += dy * player.speed;

            // Keep player in bounds
            player.x = Math.max(player.size, Math.min(WORLD_WIDTH - player.size, player.x));
            player.y = Math.max(player.size, Math.min(WORLD_HEIGHT - player.size, player.y));

            // Rotate petals
            player.angle += 0.05;
        }

        function updateEnemies() {
            // Spawn enemies
            if (Math.random() < 0.02 && enemies.length < 20) {
                spawnEnemy();
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Move towards player
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const dist = Math.hypot(dx, dy);

                if (dist > 0) {
                    enemy.x += (dx / dist) * enemy.speed;
                    enemy.y += (dy / dist) * enemy.speed;
                }

                // Check collision with player center
                const playerDist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                if (playerDist < player.size + enemy.size) {
                    player.health -= enemy.damage;
                    enemies.splice(i, 1);
                    if (player.health <= 0) {
                        gameOver();
                    }
                    continue;
                }

                // Check collision with petals
                for (let j = 0; j < player.petals.length; j++) {
                    const petal = player.petals[j];
                    const petalAngle = player.angle + petal.angle;
                    const petalX = player.x + Math.cos(petalAngle) * petal.distance;
                    const petalY = player.y + Math.sin(petalAngle) * petal.distance;

                    const petalDist = Math.hypot(enemy.x - petalX, enemy.y - petalY);
                    if (petalDist < petal.size + enemy.size) {
                        enemy.health -= petal.damage;
                        if (enemy.health <= 0) {
                            player.xp += enemy.xp;
                            if (player.xp >= player.xpNeeded) {
                                levelUp();
                            }
                            enemies.splice(i, 1);
                        }
                        break;
                    }
                }
            }
        }

        function updateCollectibles() {
            for (let i = collectiblePetals.length - 1; i >= 0; i--) {
                const petal = collectiblePetals[i];
                const dist = Math.hypot(petal.x - player.x, petal.y - player.y);

                if (dist < player.size + petal.size + 20) {
                    collectiblePetals.splice(i, 1);
                    player.petalCount++;
                    player.xp += 1;
                    if (player.xp >= player.xpNeeded) {
                        levelUp();
                    }

                    // Spawn new petal
                    collectiblePetals.push({
                        x: Math.random() * WORLD_WIDTH,
                        y: Math.random() * WORLD_HEIGHT,
                        size: 8,
                        color: PETAL_COLORS[Math.floor(Math.random() * PETAL_COLORS.length)],
                        rotation: Math.random() * Math.PI * 2
                    });
                }
            }
        }

        function updateCamera() {
            cameraX = player.x - canvas.width / 2;
            cameraY = player.y - canvas.height / 2;
        }

        function drawWorld() {
            // Draw grass background
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw darker grass patches
            ctx.fillStyle = '#7CCD7C';
            const patchSize = 50;
            for (let x = Math.floor(cameraX / patchSize) * patchSize; x < cameraX + canvas.width; x += patchSize) {
                for (let y = Math.floor(cameraY / patchSize) * patchSize; y < cameraY + canvas.height; y += patchSize) {
                    if ((x + y) % (patchSize * 2) === 0) {
                        ctx.fillRect(x - cameraX, y - cameraY, patchSize, patchSize);
                    }
                }
            }

            // Draw world border
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 10;
            ctx.strokeRect(-cameraX, -cameraY, WORLD_WIDTH, WORLD_HEIGHT);
        }

        function drawCollectibles() {
            for (let petal of collectiblePetals) {
                const screenX = petal.x - cameraX;
                const screenY = petal.y - cameraY;

                if (screenX > -20 && screenX < canvas.width + 20 &&
                    screenY > -20 && screenY < canvas.height + 20) {

                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(petal.rotation);

                    // Draw petal shape
                    ctx.fillStyle = petal.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, petal.size, petal.size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.restore();
                }
            }
        }

        function drawPlayer() {
            const screenX = player.x - cameraX;
            const screenY = player.y - cameraY;

            // Draw petals
            for (let petal of player.petals) {
                const angle = player.angle + petal.angle;
                const x = screenX + Math.cos(angle) * petal.distance;
                const y = screenY + Math.sin(angle) * petal.distance;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);

                // Petal
                ctx.fillStyle = petal.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, petal.size, petal.size * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }

            // Draw flower center
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(screenX, screenY, player.size, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw face
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(screenX - 6, screenY - 4, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(screenX + 6, screenY - 4, 3, 0, Math.PI * 2);
            ctx.fill();

            // Smile
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(screenX, screenY + 2, 8, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Health bar
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(screenX - 25, screenY - 35, 50, 8);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(screenX - 25, screenY - 35, 50 * (player.health / player.maxHealth), 8);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.strokeRect(screenX - 25, screenY - 35, 50, 8);
        }

        function drawEnemies() {
            for (let enemy of enemies) {
                const screenX = enemy.x - cameraX;
                const screenY = enemy.y - cameraY;

                if (screenX > -50 && screenX < canvas.width + 50 &&
                    screenY > -50 && screenY < canvas.height + 50) {

                    // Draw enemy body
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, enemy.size, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(screenX - enemy.size * 0.3, screenY - enemy.size * 0.2, enemy.size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(screenX + enemy.size * 0.3, screenY - enemy.size * 0.2, enemy.size * 0.2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(screenX - enemy.size * 0.3, screenY - enemy.size * 0.2, enemy.size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(screenX + enemy.size * 0.3, screenY - enemy.size * 0.2, enemy.size * 0.1, 0, Math.PI * 2);
                    ctx.fill();

                    // Health bar
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(screenX - enemy.size, screenY - enemy.size - 10, enemy.size * 2, 5);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(screenX - enemy.size, screenY - enemy.size - 10,
                        enemy.size * 2 * (enemy.health / enemy.maxHealth), 5);
                }
            }
        }

        function updateUI() {
            document.getElementById('level').textContent = player.level;
            document.getElementById('xp').textContent = player.xp;
            document.getElementById('xpNeeded').textContent = player.xpNeeded;
            document.getElementById('health').textContent = Math.max(0, Math.floor(player.health));
            document.getElementById('petals').textContent = player.petalCount;
        }

        function gameLoop() {
            if (!gameActive) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            updatePlayer();
            updateEnemies();
            updateCollectibles();
            updateCamera();

            drawWorld();
            drawCollectibles();
            drawEnemies();
            drawPlayer();

            updateUI();

            requestAnimationFrame(gameLoop);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) {
                e.preventDefault();
                keys[key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
            }
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth - 100;
            canvas.height = window.innerHeight - 100;
        });
    </script>
</body>
</html>
