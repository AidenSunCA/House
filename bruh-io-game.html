<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bruh.io - Battle Royale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            border: 3px solid #333;
            background: #000;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        .health-bar-container {
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4444);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .armor-bar-container {
            width: 300px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #aaa;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .armor-bar {
            height: 100%;
            background: linear-gradient(90deg, #4444ff, #6666ff);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        #weaponInfo {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #aliveCount {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 18px;
        }

        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid white;
            border-radius: 5px;
            pointer-events: none;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            color: white;
            text-align: center;
            display: none;
        }

        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }

        #gameOver button {
            padding: 15px 30px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }

        #gameOver button:hover {
            background: #45a049;
        }

        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            pointer-events: none;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a3d0f 0%, #2d5016 50%, #1e3c72 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #startScreen h1 {
            font-size: 72px;
            color: #fff;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 20px;
            font-family: 'Arial Black', Arial, sans-serif;
        }

        #startScreen .subtitle {
            font-size: 24px;
            color: #aaa;
            margin-bottom: 40px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #startScreen .info-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            max-width: 600px;
            border: 2px solid #2ecc71;
        }

        #startScreen .info-box h2 {
            color: #2ecc71;
            margin-bottom: 15px;
            font-size: 20px;
        }

        #startScreen .info-box p {
            color: #fff;
            line-height: 1.8;
            margin: 10px 0;
            font-size: 16px;
        }

        #startButton {
            padding: 20px 60px;
            font-size: 32px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Arial Black', Arial, sans-serif;
        }

        #startButton:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(46, 204, 113, 0.6);
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        #startButton:active {
            transform: scale(0.98);
        }

        #mapSelection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a3d0f 0%, #2d5016 50%, #1e3c72 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #mapSelection h1 {
            font-size: 48px;
            color: #fff;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 40px;
            font-family: 'Arial Black', Arial, sans-serif;
        }

        .map-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-bottom: 30px;
        }

        .map-card {
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #555;
            border-radius: 10px;
            padding: 20px;
            width: 300px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .map-card:hover {
            border-color: #2ecc71;
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(46, 204, 113, 0.6);
        }

        .map-card.selected {
            border-color: #FFD700;
            background: rgba(46, 204, 113, 0.2);
        }

        .map-preview {
            width: 100%;
            height: 150px;
            border-radius: 5px;
            margin-bottom: 15px;
            position: relative;
        }

        .map-card h3 {
            color: #2ecc71;
            font-size: 24px;
            margin-bottom: 10px;
        }

        .map-card p {
            color: #aaa;
            font-size: 14px;
            line-height: 1.6;
        }

        #continueButton {
            padding: 15px 50px;
            font-size: 28px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Arial Black', Arial, sans-serif;
        }

        #continueButton:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(255, 215, 0, 0.6);
        }

        #continueButton:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>

        <div id="ui">
            <div class="health-bar-container">
                <div class="health-bar" id="healthBar">HP: 100/100</div>
            </div>
            <div class="armor-bar-container">
                <div class="armor-bar" id="armorBar">Armor: 0/50</div>
            </div>
            <div id="weaponInfo">
                <div>Weapon: Pistol</div>
                <div id="ammoDisplay">Ammo: ‚àû</div>
            </div>
            <div id="aliveCount">Alive: 10</div>
            <div id="mapInfo" style="background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px; margin-top: 10px;">
                Map: Forest
            </div>
        </div>

        <canvas id="minimap" width="200" height="200"></canvas>

        <div id="instructions">
            <strong>Controls:</strong><br>
            WASD - Move<br>
            Mouse - Aim<br>
            Click - Shoot<br>
            E - Pick up item<br>
            1/2 - Switch weapons
        </div>

        <div id="gameOver">
            <h1 id="resultText">YOU DIED</h1>
            <p id="placeText">Place: #5</p>
            <button onclick="restartGame()">Play Again</button>
        </div>

        <div id="startScreen">
            <h1>BRUH.IO</h1>
            <div class="subtitle">Battle Royale Forest Warfare</div>

            <div class="info-box">
                <h2>Game Info</h2>
                <p><strong>Objective:</strong> Be the last player standing in the forest!</p>
                <p><strong>Players:</strong> 10 (You + 9 Bots)</p>
                <p><strong>Map Size:</strong> 6000x6000 units with 300 trees</p>
                <p><strong>Items:</strong> 30 Weapons ‚Ä¢ 20 Kevlar Vests ‚Ä¢ 15 Medkits</p>
            </div>

            <div class="info-box">
                <h2>Controls</h2>
                <p><strong>WASD</strong> - Move ‚Ä¢ <strong>Mouse</strong> - Aim ‚Ä¢ <strong>Click</strong> - Shoot</p>
                <p><strong>E</strong> - Pick up items ‚Ä¢ <strong>1/2</strong> - Switch weapons</p>
            </div>

            <button id="startButton" onclick="showMapSelection()">START GAME</button>
        </div>

        <div id="mapSelection">
            <h1>SELECT A MAP</h1>

            <div class="map-grid">
                <div class="map-card" onclick="selectMap('forest')">
                    <canvas class="map-preview" id="forestPreview"></canvas>
                    <h3>üå≤ FOREST</h3>
                    <p><strong>Classic Battle Royale</strong></p>
                    <p>‚Ä¢ Dense forest with 300 trees<br>‚Ä¢ Natural cover and obstacles<br>‚Ä¢ 6000x6000 map</p>
                </div>

                <div class="map-card" onclick="selectMap('desert')">
                    <canvas class="map-preview" id="desertPreview"></canvas>
                    <h3>üèúÔ∏è DESERT</h3>
                    <p><strong>Open Warfare</strong></p>
                    <p>‚Ä¢ Sandy dunes and rocks<br>‚Ä¢ Limited cover, long sightlines<br>‚Ä¢ 6000x6000 map</p>
                </div>

                <div class="map-card" onclick="selectMap('urban')">
                    <canvas class="map-preview" id="urbanPreview"></canvas>
                    <h3>üèôÔ∏è URBAN</h3>
                    <p><strong>City Combat</strong></p>
                    <p>‚Ä¢ Buildings and structures<br>‚Ä¢ Close-quarters combat<br>‚Ä¢ 6000x6000 map</p>
                </div>

                <div class="map-card" onclick="selectMap('snow')">
                    <canvas class="map-preview" id="snowPreview"></canvas>
                    <h3>‚ùÑÔ∏è SNOW</h3>
                    <p><strong>Winter Warfare</strong></p>
                    <p>‚Ä¢ Frozen landscape with ice trees<br>‚Ä¢ Slippery terrain<br>‚Ä¢ 6000x6000 map</p>
                </div>
            </div>

            <button id="continueButton" onclick="continueToGame()" disabled>CONTINUE</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d');

        // Map selection
        let selectedMap = null;

        // Game constants
        const WORLD_SIZE = 6000; // Doubled the map size!
        const PLAYER_SIZE = 30;
        const BOT_SIZE = 30;
        const BULLET_SIZE = 5;
        const INITIAL_SAFE_ZONE = WORLD_SIZE - 400;
        const SAFE_ZONE_SHRINK_RATE = 0.5; // Slightly faster shrink for larger map
        const GAS_DAMAGE = 2;
        const MIN_SPAWN_DISTANCE = 800; // Minimum distance between spawns
        const LOCK_ON_RANGE = 500; // Range at which bots lock onto player
        const DISENGAGE_RANGE = 800; // Range at which bots stop chasing player

        // Game state
        let player = {
            x: WORLD_SIZE / 2,
            y: WORLD_SIZE / 2,
            vx: 0,
            vy: 0,
            speed: 4,
            health: 100,
            maxHealth: 100,
            armor: 0,
            maxArmor: 50,
            weapon1: { ...weapons.pistol },
            weapon2: null, // Second weapon slot (empty by default)
            currentWeapon: 1, // Which weapon is currently active (1 or 2)
            lastShot: 0,
            angle: 0,
            alive: true
        };

        let keys = {};
        let mouse = { x: 0, y: 0, down: false };
        let camera = { x: 0, y: 0 };
        let bullets = [];
        let bots = [];
        let pickups = [];
        let trees = [];
        let safeZoneRadius = INITIAL_SAFE_ZONE;
        let safeZoneCenter = { x: WORLD_SIZE / 2, y: WORLD_SIZE / 2 };
        let gameTime = 0;
        let aliveCount = 10;

        // Weapon types
        const weapons = {
            pistol: { name: 'Pistol', damage: 20, fireRate: 300, bulletSpeed: 12, range: 500, color: '#888', pellets: 1, spread: 0 },
            smg: { name: 'SMG', damage: 15, fireRate: 100, bulletSpeed: 14, range: 400, color: '#00ff00', pellets: 1, spread: 0 },
            shotgun: { name: 'Shotgun', damage: 12, fireRate: 800, bulletSpeed: 10, range: 300, color: '#ff8800', pellets: 8, spread: 0.3 },
            rifle: { name: 'Rifle', damage: 35, fireRate: 200, bulletSpeed: 18, range: 700, color: '#ff0000', pellets: 1, spread: 0 },
            sniper: { name: 'Sniper', damage: 100, fireRate: 1500, bulletSpeed: 25, range: 1000, color: '#0088ff', pellets: 1, spread: 0 }
        };

        // Initialize game
        function init() {
            bullets = [];
            bots = [];
            pickups = [];
            trees = [];
            safeZoneRadius = INITIAL_SAFE_ZONE;
            gameTime = 0;
            aliveCount = 10;

            // Track all spawn positions to ensure minimum distance
            let spawnPositions = [];

            // Spawn player at random location
            const playerSpawn = getRandomSpawnPosition(spawnPositions);
            player.x = playerSpawn.x;
            player.y = playerSpawn.y;
            player.health = 100;
            player.armor = 0;
            player.alive = true;
            player.weapon1 = { ...weapons.pistol };
            player.weapon2 = null;
            player.currentWeapon = 1;

            // Map-specific player speed adjustments
            switch(selectedMap) {
                case 'desert':
                    player.speed = 3.5; // Slower in sand
                    break;
                case 'urban':
                    player.speed = 4.5; // Faster on pavement
                    break;
                case 'snow':
                    player.speed = 3; // Slowest on ice/snow
                    break;
                default: // forest
                    player.speed = 4; // Normal speed
            }

            spawnPositions.push(playerSpawn);

            // Initialize camera to player position
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
            camera.x = Math.max(0, Math.min(WORLD_SIZE - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(WORLD_SIZE - canvas.height, camera.y));

            // Generate structured map layout
            generateMapLayout();

            // Spawn bots with spread spawning
            for (let i = 0; i < 9; i++) {
                spawnBot(spawnPositions);
            }

            // Spawn more pickups for the larger map
            for (let i = 0; i < 30; i++) {
                spawnWeaponPickup();
            }

            for (let i = 0; i < 20; i++) {
                spawnArmorPickup();
            }

            // Spawn medkits
            for (let i = 0; i < 15; i++) {
                spawnMedkit();
            }

            document.getElementById('gameOver').style.display = 'none';
        }

        function getRandomSpawnPosition(existingSpawns) {
            let attempts = 0;
            const maxAttempts = 100;

            while (attempts < maxAttempts) {
                const x = Math.random() * (WORLD_SIZE - 400) + 200;
                const y = Math.random() * (WORLD_SIZE - 400) + 200;

                // Check if this position is far enough from all existing spawns
                let validSpawn = true;
                for (let spawn of existingSpawns) {
                    const dist = Math.hypot(x - spawn.x, y - spawn.y);
                    if (dist < MIN_SPAWN_DISTANCE) {
                        validSpawn = false;
                        break;
                    }
                }

                if (validSpawn) {
                    return { x, y };
                }

                attempts++;
            }

            // If we can't find a valid spawn after max attempts, just return a random position
            return {
                x: Math.random() * (WORLD_SIZE - 400) + 200,
                y: Math.random() * (WORLD_SIZE - 400) + 200
            };
        }

        // Generate structured map layouts
        function generateMapLayout() {
            const currentMap = selectedMap || 'forest';
            trees = []; // Clear existing obstacles

            switch(currentMap) {
                case 'desert':
                    generateDesertMap();
                    break;
                case 'urban':
                    generateUrbanMap();
                    break;
                case 'snow':
                    generateSnowMap();
                    break;
                default:
                    generateForestMap();
            }
        }

        function generateForestMap() {
            // Create tree clusters with clearings for strategic gameplay
            const numClusters = 15;

            for (let i = 0; i < numClusters; i++) {
                const clusterX = Math.random() * WORLD_SIZE;
                const clusterY = Math.random() * WORLD_SIZE;
                const clusterSize = 15 + Math.random() * 10;
                const clusterRadius = 200 + Math.random() * 300;

                for (let j = 0; j < clusterSize; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * clusterRadius;
                    trees.push({
                        x: clusterX + Math.cos(angle) * dist,
                        y: clusterY + Math.sin(angle) * dist,
                        radius: 20 + Math.random() * 30,
                        type: Math.floor(Math.random() * 3)
                    });
                }
            }

            // Add scattered trees in clearings
            for (let i = 0; i < 50; i++) {
                trees.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    radius: 20 + Math.random() * 25,
                    type: Math.floor(Math.random() * 3)
                });
            }
        }

        function generateDesertMap() {
            // Create rock formations and open areas
            const numFormations = 8;

            for (let i = 0; i < numFormations; i++) {
                const formX = Math.random() * WORLD_SIZE;
                const formY = Math.random() * WORLD_SIZE;
                const formSize = 8 + Math.random() * 7;
                const formRadius = 150 + Math.random() * 200;

                for (let j = 0; j < formSize; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * formRadius;
                    trees.push({
                        x: formX + Math.cos(angle) * dist,
                        y: formY + Math.sin(angle) * dist,
                        radius: 25 + Math.random() * 35,
                        type: Math.floor(Math.random() * 2)
                    });
                }
            }

            // Add scattered rocks
            for (let i = 0; i < 30; i++) {
                trees.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    radius: 20 + Math.random() * 30,
                    type: Math.floor(Math.random() * 2)
                });
            }

            // Add large dune obstacles
            for (let i = 0; i < 10; i++) {
                trees.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    radius: 50 + Math.random() * 40,
                    type: 0
                });
            }
        }

        function generateUrbanMap() {
            // Create city blocks with streets
            const blockSize = 400;
            const streetWidth = 150;

            for (let x = 300; x < WORLD_SIZE - 300; x += blockSize) {
                for (let y = 300; y < WORLD_SIZE - 300; y += blockSize) {
                    // Create 3-5 buildings per block
                    const buildingsInBlock = 3 + Math.floor(Math.random() * 3);

                    for (let i = 0; i < buildingsInBlock; i++) {
                        const offsetX = (Math.random() - 0.5) * (blockSize - streetWidth);
                        const offsetY = (Math.random() - 0.5) * (blockSize - streetWidth);

                        trees.push({
                            x: x + offsetX,
                            y: y + offsetY,
                            radius: 35 + Math.random() * 45,
                            type: 0
                        });
                    }
                }
            }

            // Add scattered smaller structures
            for (let i = 0; i < 30; i++) {
                trees.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    radius: 25 + Math.random() * 30,
                    type: 0
                });
            }
        }

        function generateSnowMap() {
            // Create ice forest with paths
            const numGroves = 18;

            for (let i = 0; i < numGroves; i++) {
                const groveX = Math.random() * WORLD_SIZE;
                const groveY = Math.random() * WORLD_SIZE;
                const groveSize = 12 + Math.random() * 8;
                const groveRadius = 180 + Math.random() * 250;

                for (let j = 0; j < groveSize; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * groveRadius;
                    trees.push({
                        x: groveX + Math.cos(angle) * dist,
                        y: groveY + Math.sin(angle) * dist,
                        radius: 20 + Math.random() * 30,
                        type: Math.floor(Math.random() * 3)
                    });
                }
            }

            // Add frozen obstacles
            for (let i = 0; i < 60; i++) {
                trees.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    radius: 18 + Math.random() * 28,
                    type: Math.floor(Math.random() * 3)
                });
            }
        }

        function spawnBot(spawnPositions) {
            const spawnPos = getRandomSpawnPosition(spawnPositions);

            // Map-specific bot speed
            let botSpeed;
            switch(selectedMap) {
                case 'desert':
                    botSpeed = 2.5; // Slower in sand
                    break;
                case 'urban':
                    botSpeed = 3.5; // Faster on pavement
                    break;
                case 'snow':
                    botSpeed = 2.2; // Slowest on ice/snow
                    break;
                default: // forest
                    botSpeed = 3; // Normal speed
            }

            const bot = {
                x: spawnPos.x,
                y: spawnPos.y,
                vx: 0,
                vy: 0,
                speed: botSpeed,
                health: 100,
                armor: 0,
                weapon: { ...weapons[Object.keys(weapons)[Math.floor(Math.random() * Object.keys(weapons).length)]] },
                lastShot: 0,
                angle: Math.random() * Math.PI * 2,
                alive: true,
                target: null,
                stateTimer: 0,
                lockedOn: false, // Track if bot is locked onto a target
                lastSeenPlayerX: 0,
                lastSeenPlayerY: 0
            };

            spawnPositions.push(spawnPos);
            bots.push(bot);
        }

        function spawnWeaponPickup() {
            const weaponKeys = Object.keys(weapons).filter(k => k !== 'pistol');
            const weaponKey = weaponKeys[Math.floor(Math.random() * weaponKeys.length)];
            const pos = getStrategicPickupPosition();
            pickups.push({
                x: pos.x,
                y: pos.y,
                type: 'weapon',
                weapon: { ...weapons[weaponKey] },
                size: 25
            });
        }

        function spawnArmorPickup() {
            const pos = getStrategicPickupPosition();
            pickups.push({
                x: pos.x,
                y: pos.y,
                type: 'armor',
                amount: 15,
                size: 20
            });
        }

        function spawnMedkit() {
            const pos = getStrategicPickupPosition();
            pickups.push({
                x: pos.x,
                y: pos.y,
                type: 'medkit',
                healAmount: 50,
                size: 22
            });
        }

        // Get strategic positions for pickups (in open areas, not inside obstacles)
        function getStrategicPickupPosition() {
            let attempts = 0;
            const maxAttempts = 50;

            while (attempts < maxAttempts) {
                const x = Math.random() * (WORLD_SIZE - 200) + 100;
                const y = Math.random() * (WORLD_SIZE - 200) + 100;

                // Check if position is clear of obstacles
                let clearSpace = true;
                for (let tree of trees) {
                    const dist = Math.hypot(x - tree.x, y - tree.y);
                    if (dist < tree.radius + 50) {
                        clearSpace = false;
                        break;
                    }
                }

                if (clearSpace) {
                    return { x, y };
                }

                attempts++;
            }

            // Fallback to random position if no clear space found
            return {
                x: Math.random() * (WORLD_SIZE - 200) + 100,
                y: Math.random() * (WORLD_SIZE - 200) + 100
            };
        }

        // Helper function to get active weapon
        function getActiveWeapon(entity) {
            if (entity === player) {
                return entity.currentWeapon === 1 ? entity.weapon1 : entity.weapon2;
            }
            return entity.weapon; // Bots still have single weapon
        }

        // Input handlers
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            keys[key] = true;

            // Weapon switching with 1 and 2 keys
            if (key === '1') {
                player.currentWeapon = 1;
            } else if (key === '2' && player.weapon2 !== null) {
                player.currentWeapon = 2;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => {
            mouse.down = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouse.down = false;
        });

        // Game loop
        function update() {
            if (!player.alive) return;

            gameTime++;

            // Update player movement
            player.vx = 0;
            player.vy = 0;

            if (keys['w'] || keys['arrowup']) player.vy = -player.speed;
            if (keys['s'] || keys['arrowdown']) player.vy = player.speed;
            if (keys['a'] || keys['arrowleft']) player.vx = -player.speed;
            if (keys['d'] || keys['arrowright']) player.vx = player.speed;

            // Normalize diagonal movement
            if (player.vx !== 0 && player.vy !== 0) {
                player.vx *= 0.707;
                player.vy *= 0.707;
            }

            player.x += player.vx;
            player.y += player.vy;

            // Check collision with trees
            checkTreeCollision(player);

            // Keep player in world bounds
            player.x = Math.max(0, Math.min(WORLD_SIZE, player.x));
            player.y = Math.max(0, Math.min(WORLD_SIZE, player.y));

            // Update player angle
            const worldMouseX = mouse.x + camera.x;
            const worldMouseY = mouse.y + camera.y;
            player.angle = Math.atan2(worldMouseY - player.y, worldMouseX - player.x);

            // Shooting
            const activeWeapon = getActiveWeapon(player);
            if (activeWeapon && mouse.down && Date.now() - player.lastShot > activeWeapon.fireRate) {
                shoot(player);
                player.lastShot = Date.now();
            }

            // Check for pickups
            if (keys['e']) {
                for (let i = pickups.length - 1; i >= 0; i--) {
                    const pickup = pickups[i];
                    const dist = Math.hypot(player.x - pickup.x, player.y - pickup.y);
                    if (dist < 50) {
                        if (pickup.type === 'weapon') {
                            // Add weapon to current active slot, or to slot 2 if slot 1 is occupied
                            if (player.currentWeapon === 1) {
                                player.weapon1 = { ...pickup.weapon };
                            } else if (player.weapon2 === null) {
                                player.weapon2 = { ...pickup.weapon };
                                player.currentWeapon = 2; // Auto-switch to new weapon
                            } else {
                                // Replace current weapon
                                if (player.currentWeapon === 1) {
                                    player.weapon1 = { ...pickup.weapon };
                                } else {
                                    player.weapon2 = { ...pickup.weapon };
                                }
                            }
                            pickups.splice(i, 1);
                        } else if (pickup.type === 'armor') {
                            player.armor = Math.min(player.maxArmor, player.armor + pickup.amount);
                            pickups.splice(i, 1);
                        } else if (pickup.type === 'medkit') {
                            // Only pick up medkit if not at full health
                            if (player.health < player.maxHealth) {
                                player.health = Math.min(player.maxHealth, player.health + pickup.healAmount);
                                pickups.splice(i, 1);
                            }
                        }
                    }
                }
            }

            // Update bots
            updateBots();

            // Update bullets
            updateBullets();

            // Shrink safe zone
            if (gameTime > 180) { // Start shrinking after 3 seconds
                safeZoneRadius = Math.max(400, safeZoneRadius - SAFE_ZONE_SHRINK_RATE);
            }

            // Check gas damage
            checkGasDamage();

            // Update camera
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
            camera.x = Math.max(0, Math.min(WORLD_SIZE - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(WORLD_SIZE - canvas.height, camera.y));

            // Update alive count
            aliveCount = 1 + bots.filter(b => b.alive).length;

            // Check win condition
            if (aliveCount === 1 && player.alive) {
                endGame(true);
            }
        }

        function updateBots() {
            for (let bot of bots) {
                if (!bot.alive) continue;

                bot.stateTimer--;

                // Calculate distance to player
                const distToPlayer = Math.hypot(player.x - bot.x, player.y - bot.y);

                // Lock-on system
                if (player.alive) {
                    // If not locked on, check if player entered lock-on range
                    if (!bot.lockedOn && distToPlayer < LOCK_ON_RANGE) {
                        bot.lockedOn = true;
                        bot.lastSeenPlayerX = player.x;
                        bot.lastSeenPlayerY = player.y;
                    }
                    // If locked on, update last seen position and check disengage range
                    else if (bot.lockedOn) {
                        if (distToPlayer < DISENGAGE_RANGE) {
                            // Still in range, update last seen position
                            bot.lastSeenPlayerX = player.x;
                            bot.lastSeenPlayerY = player.y;
                        } else {
                            // Player escaped! Disengage
                            bot.lockedOn = false;
                        }
                    }
                }

                // Improved AI with lock-on behavior
                if (bot.stateTimer <= 0) {
                    if (bot.lockedOn && player.alive) {
                        // LOCKED ON MODE - Chase and attack the player
                        bot.angle = Math.atan2(player.y - bot.y, player.x - bot.x);
                        bot.vx = Math.cos(bot.angle) * bot.speed;
                        bot.vy = Math.sin(bot.angle) * bot.speed;

                        // Shoot if in range
                        if (distToPlayer < LOCK_ON_RANGE && Date.now() - bot.lastShot > bot.weapon.fireRate) {
                            shoot(bot);
                            bot.lastShot = Date.now();
                        }

                        bot.stateTimer = 30; // Update frequently when locked on
                    } else {
                        // EXPLORATION MODE - Random wandering
                        const rand = Math.random();

                        if (rand < 0.6) {
                            // 60% chance: Move in a random direction
                            const randomAngle = Math.random() * Math.PI * 2;
                            bot.angle = randomAngle;
                            bot.vx = Math.cos(randomAngle) * bot.speed;
                            bot.vy = Math.sin(randomAngle) * bot.speed;
                            bot.stateTimer = 120 + Math.random() * 120; // Random duration 2-4 seconds
                        } else if (rand < 0.85) {
                            // 25% chance: Move towards safe zone center (stay safe)
                            const angleToCenter = Math.atan2(safeZoneCenter.y - bot.y, safeZoneCenter.x - bot.x);
                            bot.angle = angleToCenter;
                            bot.vx = Math.cos(angleToCenter) * bot.speed;
                            bot.vy = Math.sin(angleToCenter) * bot.speed;
                            bot.stateTimer = 180;
                        } else {
                            // 15% chance: Stop and look around
                            bot.vx = 0;
                            bot.vy = 0;
                            bot.angle += (Math.random() - 0.5) * Math.PI; // Turn randomly
                            bot.stateTimer = 60;
                        }
                    }
                }

                bot.x += bot.vx;
                bot.y += bot.vy;

                // Check collision with trees
                checkTreeCollision(bot);

                // Keep in bounds
                bot.x = Math.max(0, Math.min(WORLD_SIZE, bot.x));
                bot.y = Math.max(0, Math.min(WORLD_SIZE, bot.y));
            }
        }

        function checkTreeCollision(entity) {
            for (let tree of trees) {
                const dist = Math.hypot(entity.x - tree.x, entity.y - tree.y);
                const minDist = (entity === player ? PLAYER_SIZE : BOT_SIZE) / 2 + tree.radius;

                if (dist < minDist) {
                    // Push entity away from tree
                    const angle = Math.atan2(entity.y - tree.y, entity.x - tree.x);
                    entity.x = tree.x + Math.cos(angle) * minDist;
                    entity.y = tree.y + Math.sin(angle) * minDist;
                }
            }
        }

        function shoot(entity) {
            const weapon = getActiveWeapon(entity);
            if (!weapon) return; // No weapon equipped

            const baseSpread = entity === player ? 0 : 0.1;
            const weaponSpread = weapon.spread || 0;
            const pellets = weapon.pellets || 1;

            // Fire multiple pellets for shotgun
            for (let i = 0; i < pellets; i++) {
                // Calculate spread angle for each pellet
                let spreadAngle;
                if (pellets > 1) {
                    // Shotgun spread - distribute pellets in a cone
                    spreadAngle = entity.angle + (Math.random() - 0.5) * weaponSpread + baseSpread;
                } else {
                    // Regular weapons - minimal spread
                    spreadAngle = entity.angle + (Math.random() - 0.5) * baseSpread;
                }

                bullets.push({
                    x: entity.x,
                    y: entity.y,
                    vx: Math.cos(spreadAngle) * weapon.bulletSpeed,
                    vy: Math.sin(spreadAngle) * weapon.bulletSpeed,
                    damage: weapon.damage,
                    range: weapon.range,
                    traveled: 0,
                    owner: entity,
                    color: weapon.color,
                    isPellet: pellets > 1 // Mark shotgun pellets for smaller rendering
                });
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.traveled += Math.hypot(bullet.vx, bullet.vy);

                // Remove if out of range
                if (bullet.traveled > bullet.range ||
                    bullet.x < 0 || bullet.x > WORLD_SIZE ||
                    bullet.y < 0 || bullet.y > WORLD_SIZE) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with trees
                let hitTree = false;
                for (let tree of trees) {
                    const dist = Math.hypot(bullet.x - tree.x, bullet.y - tree.y);
                    if (dist < tree.radius) {
                        hitTree = true;
                        break;
                    }
                }
                if (hitTree) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with player
                if (bullet.owner !== player && player.alive) {
                    const dist = Math.hypot(bullet.x - player.x, bullet.y - player.y);
                    if (dist < PLAYER_SIZE / 2) {
                        damageEntity(player, bullet.damage);
                        bullets.splice(i, 1);
                        continue;
                    }
                }

                // Check collision with bots
                for (let bot of bots) {
                    if (bullet.owner !== bot && bot.alive) {
                        const dist = Math.hypot(bullet.x - bot.x, bullet.y - bot.y);
                        if (dist < BOT_SIZE / 2) {
                            damageEntity(bot, bullet.damage);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }

        function damageEntity(entity, damage) {
            if (entity.armor > 0) {
                const armorDamage = Math.min(entity.armor, damage);
                entity.armor -= armorDamage;
                damage -= armorDamage;
            }

            entity.health -= damage;

            if (entity.health <= 0) {
                entity.alive = false;
                if (entity === player) {
                    endGame(false);
                }
            }
        }

        function checkGasDamage() {
            // Check player
            const playerDist = Math.hypot(player.x - safeZoneCenter.x, player.y - safeZoneCenter.y);
            if (playerDist > safeZoneRadius) {
                damageEntity(player, GAS_DAMAGE);
            }

            // Check bots
            for (let bot of bots) {
                if (!bot.alive) continue;
                const botDist = Math.hypot(bot.x - safeZoneCenter.x, bot.y - safeZoneCenter.y);
                if (botDist > safeZoneRadius) {
                    damageEntity(bot, GAS_DAMAGE);
                }
            }
        }

        function endGame(won) {
            const gameOverDiv = document.getElementById('gameOver');
            const resultText = document.getElementById('resultText');
            const placeText = document.getElementById('placeText');

            if (won) {
                resultText.textContent = 'WINNER!';
                resultText.style.color = '#FFD700';
                placeText.textContent = 'Victory Royale!';
            } else {
                resultText.textContent = 'YOU DIED';
                resultText.style.color = '#ff0000';
                placeText.textContent = `Place: #${aliveCount}`;
            }

            gameOverDiv.style.display = 'block';
        }

        function restartGame() {
            init();
        }

        // Render
        function render() {
            // Don't render game world until game has started
            if (!gameStarted) {
                // Just clear to black while waiting
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                return;
            }

            // Clear canvas with map-themed ground color
            let groundColor, patch1Color, patch2Color;

            // Ensure we have a valid map selected
            const currentMap = selectedMap || 'forest';

            switch(currentMap) {
                case 'desert':
                    groundColor = '#d4a574';
                    patch1Color = '#c19a6b';
                    patch2Color = '#8b7355';
                    break;
                case 'urban':
                    groundColor = '#505050';
                    patch1Color = '#404040';
                    patch2Color = '#606060';
                    break;
                case 'snow':
                    groundColor = '#f0f8ff';
                    patch1Color = '#e6f2ff';
                    patch2Color = '#d0e8ff';
                    break;
                default: // forest
                    groundColor = '#3a5a2a';
                    patch1Color = '#2d4a1f';
                    patch2Color = '#4a6b3a';
            }

            // First, fill the entire canvas with the background color
            ctx.fillStyle = groundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw ground patches
            ctx.fillStyle = patch1Color;
            for (let x = 0; x <= WORLD_SIZE; x += 200) {
                for (let y = 0; y <= WORLD_SIZE; y += 200) {
                    ctx.fillRect(x + 50, y + 50, 100, 100);
                }
            }

            // Draw texture patches
            ctx.fillStyle = patch2Color;
            for (let x = 0; x <= WORLD_SIZE; x += 150) {
                for (let y = 0; y <= WORLD_SIZE; y += 150) {
                    const offsetX = (x * 7) % 50;
                    const offsetY = (y * 11) % 50;
                    ctx.beginPath();
                    ctx.arc(x + offsetX, y + offsetY, 30, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw safe zone
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(safeZoneCenter.x, safeZoneCenter.y, safeZoneRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Draw gas (outside safe zone)
            ctx.fillStyle = 'rgba(100, 0, 100, 0.4)'; // Darker purple gas
            ctx.fillRect(0, 0, WORLD_SIZE, WORLD_SIZE);
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(safeZoneCenter.x, safeZoneCenter.y, safeZoneRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';

            // Draw obstacles (trees/rocks/buildings) based on map
            for (let tree of trees) {
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(tree.x + 5, tree.y + tree.radius + 5, tree.radius * 0.6, tree.radius * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Map-specific obstacle rendering
                if (currentMap === 'desert') {
                    // Draw rocks/cacti for desert
                    ctx.fillStyle = '#8b7355';
                    ctx.strokeStyle = '#6b5845';
                    ctx.lineWidth = 2;

                    if (tree.type === 0) {
                        // Round rock
                        ctx.beginPath();
                        ctx.arc(tree.x, tree.y, tree.radius * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        // Tall rock formation
                        ctx.beginPath();
                        ctx.ellipse(tree.x, tree.y, tree.radius * 0.6, tree.radius, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                } else if (currentMap === 'urban') {
                    // Draw buildings for urban
                    ctx.fillStyle = '#333';
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 3;

                    const buildingWidth = tree.radius * 1.2;
                    const buildingHeight = tree.radius * 1.5;
                    ctx.fillRect(tree.x - buildingWidth/2, tree.y - buildingHeight/2, buildingWidth, buildingHeight);
                    ctx.strokeRect(tree.x - buildingWidth/2, tree.y - buildingHeight/2, buildingWidth, buildingHeight);

                    // Windows
                    ctx.fillStyle = '#ffff88';
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 2; j++) {
                            ctx.fillRect(tree.x - buildingWidth/2 + 5 + j * 15, tree.y - buildingHeight/2 + 10 + i * 15, 8, 8);
                        }
                    }
                } else if (currentMap === 'snow') {
                    // Draw ice trees for snow
                    const trunkWidth = tree.radius * 0.3;
                    const trunkHeight = tree.radius * 0.8;
                    ctx.fillStyle = '#8b9dc3';
                    ctx.fillRect(tree.x - trunkWidth/2, tree.y - trunkHeight/2, trunkWidth, trunkHeight);

                    if (tree.type === 0) {
                        // Round ice tree
                        ctx.fillStyle = '#b0e0e6';
                        ctx.strokeStyle = '#87ceeb';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(tree.x, tree.y - tree.radius/2, tree.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else if (tree.type === 1) {
                        // Ice pine
                        ctx.fillStyle = '#87ceeb';
                        ctx.beginPath();
                        ctx.moveTo(tree.x, tree.y - tree.radius * 1.5);
                        ctx.lineTo(tree.x - tree.radius, tree.y + tree.radius/2);
                        ctx.lineTo(tree.x + tree.radius, tree.y + tree.radius/2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#5f9ea0';
                        ctx.stroke();
                    } else {
                        // Clustered ice tree
                        ctx.fillStyle = '#add8e6';
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2;
                            const offsetX = Math.cos(angle) * tree.radius * 0.5;
                            const offsetY = Math.sin(angle) * tree.radius * 0.5;
                            ctx.beginPath();
                            ctx.arc(tree.x + offsetX, tree.y - tree.radius/2 + offsetY, tree.radius * 0.6, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                } else {
                    // Default forest trees
                    ctx.fillStyle = '#4a3522';
                    const trunkWidth = tree.radius * 0.3;
                    const trunkHeight = tree.radius * 0.8;
                    ctx.fillRect(tree.x - trunkWidth/2, tree.y - trunkHeight/2, trunkWidth, trunkHeight);

                    if (tree.type === 0) {
                        // Round bushy tree
                        ctx.fillStyle = '#2d5016';
                        ctx.beginPath();
                        ctx.arc(tree.x, tree.y - tree.radius/2, tree.radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Highlight
                        ctx.fillStyle = '#3d6b1f';
                        ctx.beginPath();
                        ctx.arc(tree.x - tree.radius/4, tree.y - tree.radius/2 - tree.radius/4, tree.radius * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (tree.type === 1) {
                        // Pine tree
                        ctx.fillStyle = '#1a3d0f';
                        ctx.beginPath();
                        ctx.moveTo(tree.x, tree.y - tree.radius * 1.5);
                        ctx.lineTo(tree.x - tree.radius, tree.y + tree.radius/2);
                        ctx.lineTo(tree.x + tree.radius, tree.y + tree.radius/2);
                        ctx.closePath();
                        ctx.fill();

                        // Middle layer
                        ctx.beginPath();
                        ctx.moveTo(tree.x, tree.y - tree.radius);
                        ctx.lineTo(tree.x - tree.radius * 0.8, tree.y + tree.radius/3);
                        ctx.lineTo(tree.x + tree.radius * 0.8, tree.y + tree.radius/3);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Oak tree with multiple clusters
                        ctx.fillStyle = '#2a4d1a';
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2;
                            const offsetX = Math.cos(angle) * tree.radius * 0.5;
                            const offsetY = Math.sin(angle) * tree.radius * 0.5;
                            ctx.beginPath();
                            ctx.arc(tree.x + offsetX, tree.y - tree.radius/2 + offsetY, tree.radius * 0.6, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            // Draw pickups
            for (let pickup of pickups) {
                if (pickup.type === 'weapon') {
                    ctx.fillStyle = pickup.weapon.color;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pickup.x, pickup.y, pickup.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Draw pickup label
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(pickup.weapon.name, pickup.x, pickup.y - 20);
                } else if (pickup.type === 'armor') {
                    // Draw bulletproof vest/armor
                    ctx.fillStyle = '#1a4d2e'; // Dark green vest color
                    ctx.strokeStyle = '#2ecc71'; // Bright green outline
                    ctx.lineWidth = 3;

                    // Draw vest body (rounded rectangle)
                    const vestWidth = 25;
                    const vestHeight = 30;
                    ctx.beginPath();
                    ctx.roundRect(pickup.x - vestWidth/2, pickup.y - vestHeight/2, vestWidth, vestHeight, 4);
                    ctx.fill();
                    ctx.stroke();

                    // Draw vest straps/details
                    ctx.strokeStyle = '#27ae60';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(pickup.x - 8, pickup.y - 10);
                    ctx.lineTo(pickup.x - 8, pickup.y + 10);
                    ctx.moveTo(pickup.x + 8, pickup.y - 10);
                    ctx.lineTo(pickup.x + 8, pickup.y + 10);
                    ctx.stroke();

                    // Draw armor plates (rectangles)
                    ctx.fillStyle = '#34495e';
                    ctx.fillRect(pickup.x - 6, pickup.y - 6, 12, 5);
                    ctx.fillRect(pickup.x - 6, pickup.y + 1, 12, 5);

                    // Draw label
                    ctx.fillStyle = '#2ecc71';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('KEVLAR VEST', pickup.x, pickup.y - 25);
                    ctx.font = '10px Arial';
                    ctx.fillText('+15 Armor', pickup.x, pickup.y + 25);
                } else if (pickup.type === 'medkit') {
                    // Draw medkit
                    const kitWidth = 24;
                    const kitHeight = 18;

                    // Draw white medkit case
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#cc0000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.roundRect(pickup.x - kitWidth/2, pickup.y - kitHeight/2, kitWidth, kitHeight, 3);
                    ctx.fill();
                    ctx.stroke();

                    // Draw red cross
                    ctx.fillStyle = '#ff0000';
                    // Vertical bar
                    ctx.fillRect(pickup.x - 3, pickup.y - 8, 6, 16);
                    // Horizontal bar
                    ctx.fillRect(pickup.x - 8, pickup.y - 3, 16, 6);

                    // Draw label
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('MEDKIT', pickup.x, pickup.y - 22);
                    ctx.font = '10px Arial';
                    ctx.fillText('+50 HP', pickup.x, pickup.y + 22);
                }
            }

            // Draw bullets
            for (let bullet of bullets) {
                ctx.fillStyle = bullet.color || '#ffff00';
                ctx.beginPath();
                // Shotgun pellets are smaller
                const bulletSize = bullet.isPellet ? BULLET_SIZE * 0.6 : BULLET_SIZE;
                ctx.arc(bullet.x, bullet.y, bulletSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw bots
            for (let bot of bots) {
                if (!bot.alive) continue;

                ctx.save();
                ctx.translate(bot.x, bot.y);
                ctx.rotate(bot.angle);

                // Body
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(-BOT_SIZE / 2, -BOT_SIZE / 2, BOT_SIZE, BOT_SIZE);

                // Gun
                ctx.fillStyle = bot.weapon.color;
                ctx.fillRect(0, -5, 25, 10);

                ctx.restore();

                // Health bar
                const barWidth = BOT_SIZE;
                const barHeight = 5;
                ctx.fillStyle = '#000';
                ctx.fillRect(bot.x - barWidth / 2, bot.y - BOT_SIZE / 2 - 15, barWidth, barHeight);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(bot.x - barWidth / 2, bot.y - BOT_SIZE / 2 - 15, barWidth * (bot.health / 100), barHeight);
            }

            // Draw player
            if (player.alive) {
                ctx.save();
                ctx.translate(player.x, player.y);
                ctx.rotate(player.angle);

                // Body
                ctx.fillStyle = '#4444ff';
                ctx.fillRect(-PLAYER_SIZE / 2, -PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);

                // Gun - show active weapon color
                const activeWeapon = getActiveWeapon(player);
                ctx.fillStyle = activeWeapon ? activeWeapon.color : '#888';
                ctx.fillRect(0, -5, 30, 10);

                ctx.restore();
            }

            ctx.restore();

            // Update UI
            updateUI();

            // Draw minimap
            drawMinimap();
        }

        function updateUI() {
            const healthBar = document.getElementById('healthBar');
            const armorBar = document.getElementById('armorBar');
            const weaponInfo = document.getElementById('weaponInfo');
            const aliveCountDiv = document.getElementById('aliveCount');
            const mapInfo = document.getElementById('mapInfo');

            healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
            healthBar.textContent = `HP: ${Math.max(0, Math.floor(player.health))}/${player.maxHealth}`;

            armorBar.style.width = `${(player.armor / player.maxArmor) * 100}%`;
            armorBar.textContent = `Armor: ${Math.max(0, Math.floor(player.armor))}/${player.maxArmor}`;

            // Display both weapon slots
            const weapon1Name = player.weapon1 ? player.weapon1.name : 'Empty';
            const weapon2Name = player.weapon2 ? player.weapon2.name : 'Empty';
            const activeSlot = player.currentWeapon;

            weaponInfo.innerHTML = `
                <div style="${activeSlot === 1 ? 'color: #ffff00; font-weight: bold;' : ''}">1: ${weapon1Name}</div>
                <div style="${activeSlot === 2 ? 'color: #ffff00; font-weight: bold;' : ''}">2: ${weapon2Name}</div>
                <div style="margin-top: 5px; font-size: 10px;">Press 1/2 to switch</div>
            `;

            aliveCountDiv.textContent = `Alive: ${aliveCount}`;

            // Display current map with emoji
            const currentMap = selectedMap || 'forest';
            let mapDisplay = '';
            switch(currentMap) {
                case 'desert':
                    mapDisplay = 'üèúÔ∏è Desert';
                    break;
                case 'urban':
                    mapDisplay = 'üèôÔ∏è Urban';
                    break;
                case 'snow':
                    mapDisplay = '‚ùÑÔ∏è Snow';
                    break;
                default:
                    mapDisplay = 'üå≤ Forest';
            }
            mapInfo.textContent = `Map: ${mapDisplay}`;
        }

        function drawMinimap() {
            // Map-specific background
            const currentMap = selectedMap || 'forest';
            let minimapBg, obstacleColor;
            switch(currentMap) {
                case 'desert':
                    minimapBg = '#d4a574';
                    obstacleColor = 'rgba(139, 115, 85, 0.6)';
                    break;
                case 'urban':
                    minimapBg = '#505050';
                    obstacleColor = 'rgba(51, 51, 51, 0.8)';
                    break;
                case 'snow':
                    minimapBg = '#f0f8ff';
                    obstacleColor = 'rgba(176, 224, 230, 0.7)';
                    break;
                default:
                    minimapBg = '#3a5a2a';
                    obstacleColor = 'rgba(45, 80, 22, 0.6)';
            }

            minimapCtx.fillStyle = minimapBg;
            minimapCtx.fillRect(0, 0, 200, 200);

            const scale = 200 / WORLD_SIZE;

            // Draw obstacles on minimap (only show larger ones for clarity)
            minimapCtx.fillStyle = obstacleColor;
            for (let tree of trees) {
                if (tree.radius > 35) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(tree.x * scale, tree.y * scale, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            }

            // Draw safe zone
            minimapCtx.strokeStyle = '#ffffff';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.arc(
                safeZoneCenter.x * scale,
                safeZoneCenter.y * scale,
                safeZoneRadius * scale,
                0,
                Math.PI * 2
            );
            minimapCtx.stroke();

            // Draw bots
            minimapCtx.fillStyle = '#ff4444';
            for (let bot of bots) {
                if (!bot.alive) continue;
                minimapCtx.beginPath();
                minimapCtx.arc(bot.x * scale, bot.y * scale, 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            // Draw player
            minimapCtx.fillStyle = '#4444ff';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scale, player.y * scale, 4, 0, Math.PI * 2);
            minimapCtx.fill();
        }

        // Main game loop
        let gameStarted = false;
        let animationFrameId = null;

        function gameLoop() {
            if (gameStarted) {
                update();
            }
            render();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Show map selection screen
        function showMapSelection() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('mapSelection').style.display = 'flex';
            drawMapPreviews();
        }

        // Select map function
        function selectMap(mapName) {
            selectedMap = mapName;

            // Remove selected class from all cards
            document.querySelectorAll('.map-card').forEach(card => {
                card.classList.remove('selected');
            });

            // Add selected class to clicked card
            event.target.closest('.map-card').classList.add('selected');

            // Enable continue button
            document.getElementById('continueButton').disabled = false;
        }

        // Continue to game with selected map
        function continueToGame() {
            if (!selectedMap) {
                alert('Please select a map first!');
                return;
            }

            // Hide map selection
            document.getElementById('mapSelection').style.display = 'none';

            // Initialize game with selected map
            init();
            gameStarted = true;

            // Force an immediate render to show the map
            render();
        }

        // Draw map preview canvases
        function drawMapPreviews() {
            // Forest preview
            const forestCanvas = document.getElementById('forestPreview');
            const forestCtx = forestCanvas.getContext('2d');
            forestCanvas.width = 260;
            forestCanvas.height = 150;
            forestCtx.fillStyle = '#3a5a2a';
            forestCtx.fillRect(0, 0, 260, 150);
            for (let i = 0; i < 20; i++) {
                forestCtx.fillStyle = '#2d5016';
                forestCtx.beginPath();
                forestCtx.arc(Math.random() * 260, Math.random() * 150, 10 + Math.random() * 10, 0, Math.PI * 2);
                forestCtx.fill();
            }

            // Desert preview
            const desertCanvas = document.getElementById('desertPreview');
            const desertCtx = desertCanvas.getContext('2d');
            desertCanvas.width = 260;
            desertCanvas.height = 150;
            desertCtx.fillStyle = '#d4a574';
            desertCtx.fillRect(0, 0, 260, 150);
            for (let i = 0; i < 10; i++) {
                desertCtx.fillStyle = '#8b7355';
                desertCtx.beginPath();
                desertCtx.arc(Math.random() * 260, Math.random() * 150, 15, 0, Math.PI * 2);
                desertCtx.fill();
            }

            // Urban preview
            const urbanCanvas = document.getElementById('urbanPreview');
            const urbanCtx = urbanCanvas.getContext('2d');
            urbanCanvas.width = 260;
            urbanCanvas.height = 150;
            urbanCtx.fillStyle = '#505050';
            urbanCtx.fillRect(0, 0, 260, 150);
            for (let i = 0; i < 8; i++) {
                urbanCtx.fillStyle = '#333';
                const x = (i % 4) * 60 + 10;
                const y = Math.floor(i / 4) * 70 + 10;
                urbanCtx.fillRect(x, y, 40, 60);
            }

            // Snow preview
            const snowCanvas = document.getElementById('snowPreview');
            const snowCtx = snowCanvas.getContext('2d');
            snowCanvas.width = 260;
            snowCanvas.height = 150;
            snowCtx.fillStyle = '#f0f8ff';
            snowCtx.fillRect(0, 0, 260, 150);
            for (let i = 0; i < 20; i++) {
                snowCtx.fillStyle = '#b0e0e6';
                snowCtx.beginPath();
                snowCtx.arc(Math.random() * 260, Math.random() * 150, 8 + Math.random() * 8, 0, Math.PI * 2);
                snowCtx.fill();
            }
        }

        // Restart game function (updated)
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            init();
        }

        // Don't auto-start the game - wait for player to click start
        // But start the render loop so we don't see a black screen
        gameLoop();
    </script>
</body>
</html>